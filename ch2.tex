\chapter{The Effekt language}\label{chap:effekt}

Effekt is a research-level programming language developed by the Software Engineering Group at the Universität Tübingen. It features an effect system, which provides the main features that set it apart from existing and well-known languages. Effekt can be transpiled/compiled to JavaScript, Chez Scheme or LLVM. The syntax has many similarities to Scala, which allows a very imperative programming style, while internally working on a largely functional programming model.

\section{Effects and handlers}

The main feature of Effekt are effects, which are in its core, very capable exceptions. In most traditional languages, excaptions can be thrown and then catched in a surrounding block, which is what the simplest \textit{effect} or \textit{interface} can do. Interfaces are like effects, but they can include multiple operations together that can be handled by a single handler. `Throwing' this exception would be equivalent to calling the effect operation, like |do raise()| in effect. The `catching' (handling) looks like |try \{ ... \} with raise = \{ ... \}| then.

The effects that a function needs and handles are included in its actual type signiture, so the compiler can check that all effects that are used are also handled. A |main| function can only be run if it does not have any unhandled effects. Effect handlers (also called \textit{algebraic effects}) can also be defined via a function that takes a code block as argument (often called |prog|), which can then run |try \{ prog() \} with ...| in its body. These handler functions can then be called (and in turn handle an effect) with the \textit{with} keyword, which just uses the rest of the current scope`s code as the first block argument. In this example it would be in the form of |with myExceptionHandler()|, where the rest of the call-site scope`s code will automatically become the |prog| argument, so afterwards |do raise()| can be called without writing the handler implementation inline and needing to indent all of the following code.

Effect operations can have argument types, which values of need to be provided in the operation call when using/calling the effect operation. In this example it could look like |do raise("We got an Error")|, meaning the effect operation argument is of the \textit{String} type.

\section{Contextual effect polymorphism}

The Effect language features lightweight contextual effect polymorphism, which means that the effect type signiture does not need to include any effect that could potentially be used while execution is inside the function, but just the effects that the code of the function itself \textit{needs} to work and what it actually \textit{handles}. This means that a higher order function that takes another code block, for example the |map| function, can be called with a block that uses an effect (like our |raise| example). The signiture of |map| still does not mention any needed or handled effect, as it does not use the effect directly. This effect then needs to be handled at the \textit{call-site} of |map|, meaning any effect that is handled there can be used in the code block that |map| uses.

\section{Resumtion}

Effect operations can also have a return type, which gets passed back to the call-site of the effect operation when calling the |resume| function in the handler. This continues the execution where the effect operation was called. There, the return value of the effect operation call is the value that can be passed back from the handler in the |resume| call. This makes concepts like generators and iterators possible, which are implemented in the \textit{stream} library with |read| and |emit| effects as pull and push streams. It can also pause the code execution at a point with a kind of |await| effect and later resume there, making asynchronous programming on one thread possible.

When a handler implementation goes out of scope it will also finish execution of all handler blocks of effect operation calls. This means for every call of an effect operation the handler had to handle, when it didn't directly finish the block, but jumped back with a |resume| call, it will finish the execution after the |resume| to the end of the handler function implementation. This also allows to resume multiple times, calling the continuation of the call-site of the effect operation again at a later time. It also allows for deferred modification and other concepts by doing something for every called effect operation after the handler is finished (goes out of scope).

\section{Bidirectional effects}

Effects can also use other effects that need to be handled at the call-site of the effect operation, which are called bidirectional effects. These are annotated as needed effects in the signiture of the effect operation and can be used (called) inside the handler implementation. This effect then can be used in the handler without needing to be handled at the site of the handler implementation.

\section{Data types and regions}

The base data types are \textit{String}, \textit{Bool},\textit{Int}, \textit{Double} and \textit{Char}. These can be stored as \textit{values} (`val', immutable) or \textit{variables} (`var', mutable) and literals can have one of those types (e.g. "Hello", true, 3, 5.4 and 'c'). \textit{Tuples} are a way to group multiple types into a single one, surrounded by paranthesis and separated by commas. Their fields can be accessed with numbers, like |t.1|, starting from 1.

For user defined types, the simplest form is a \textit{record}, which is like a simple struct in other languages. It can have a name (like `Vec2') and any number of named fields. A variable of a record type can just be assigned to as a whole, there is no built-in way to assign just a single field of a record or tuple. When a more complex sum/tagged union type is needed, a \textit{type} can be defined instead of a record. They consist of any number of variants, which are each defined like a record. All values and variables consisting of multiple fields can also be deconstructed in a pattern \textit{match}, where each field can be assigned to a name inside the match arm directly.

The last kind of type is an \textit{object}, which is an instance of an effect (usually an interface). It is created by writing |new MyInterface \{ ... \}| instead of a handler with |try \{ ... \} with MyInterface \{ ... \}|. This does not have fields, but all the effect operations of the respective effect can be called on it. This is a \textit{computation} type and not a \textit{value} type, which is why it is created with the `def' keyword instead of `val' or `var'. This means it cannot be returned from functions.

When an object or any other computation type needs to be returned from a function, it needs to be boxed. Boxing a computation type makes its (potentially invisible) captured \textit{capabilities} explicit in its type signiture. This includes \textit{region}s that specify which variables and effects are used by the object that need to be available in the current scope when unboxing the type to do anything with it. There are special regions for |global| and |io|, that specifies the use of the global mutable variable storage effekt uses in the background, as well as the use of input/output, like println.

\section{Type system and existential types}

The Effekt language has a strict type system that is enforced at compile time. This includes static type polymorphism, which is monomorphized at compile time. Another concept that is supported are existential types, which are user defined types that have a polymorphic type parameter in one or more of their variants. This type can then be the polymorphic type of fields inside the variant, for example the type of a |List[T]| field. When matching on this variant, the field can then just be used and that polymorphic type is known inside the match arm, without the actual type definition needing to annotate or keep that polymorhic type in its signiture.

This makes it possible, for example, to store (a reference to) an array with a generic type `T', while not mentioning `T' in the signiture of that variant`s type. Therefore values containing different types of arrays can be stored in a single collection of just the plain type values. Now a function could remove any index of any of them by just needing to know the indices, but not mentioning the underlaying generic types (`T').
