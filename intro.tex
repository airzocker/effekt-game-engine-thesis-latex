\chapwithtoc{Introduction}

Game engines are used to create video games, which makes it part of a very big industry, with a world-wide annual revenue of 134.9 billion USD in 2018\footnote{\url{https://web.archive.org/web/20190509014637/https://newzoo.com/key-numbers/}}. Video games need to do massive real-time calculations on consumer hardware, which often makes game engines showcase some of the most impressive algorithms and techniques, mainly related to computer graphics. Game engines exist in various types and flavors, like smaller ones that are made for academic research or community-driven engines to make lightweight games as easy and straight-forward as possible to implement. Other game engines are backed by big companies and are feature-rich, tailored towards performant implementation of big and graphically advanced games.

Game engines range from simple libraries that introduce often used functions for rendering, animation, sound and more to whole frameworks that manage the complete execution flow of the game. There even are big editor programs that build a game from the scripts and configuration made in a graphical user interface, which often include graphical editors for scene layout, animations, shaders, asset file management and more.

\section*{Entity Component System}

The \textit{Entity Component System} is an architectural pattern based on data oriented design. The main principle of ECS is `composition over inheritance'. This concept was covered by the book \textsf{Design Patterns: Elements of Reusable Object-Oriented Software} (Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (`Gang of Four'), 1994) among others. They covered this concept on an Object-Oriented basis, but was later expanded and taken to the extreme with Data-Oriented design patterns. The `composition over inheritance' principle has many advantages for ECS, not only related to performance, but also flexibility, making large projects easier to expand, debug and faster to change. It splits data and behavior completely, making the \textit{features/capabilities} of objects composable, instead of defining an object as a specific \textit{class} or \textit{subclass}. Performance, if optimized right, can also be much higher for large/complex scenes, as systems iterate sequentially over the required components of relevant entities. As they are mostly saved close to another, iteration is also very cache-friendly. Additionally, ECS architectures can be parallelized very easily across multiple threads, by analyzing dependencies of systems and scheduling them to avoid multiple mutable access to the same components. The ECS concept and history is elaborated further in \Cref{chap:existing}.

\section*{Effekt Language}

Effekt~\cite{brachthauser2020effects} is a research programming language developed by the Software Engineering group at the Universität Tübingen\footnote{\url{https://effekt-lang.org}}. It has an effect system and features concepts like effects, effect handlers, bidirectional effects, compile-time polymorphism, existential types and complex control flow concepts using continuations and a `program stack'. The language has so far been used mostly for smaller algorithms and systems that use the features of the language to implement them more elegantly than in other languages or to showcase its features.

\textit{Effects} are like generalized exceptions. An |effect| can be defined by a single operation (function) or an |interface| that defines multiple operations which need to be implemented to handle the effect. These operations can then be called anywhere in the program, which makes the required effect get statically added as part of the type signature of the surrounding function. This effect then needs to be handled by an \textit{effect handler} in the surrounding code, similar to an exception handler. Only programs (`main' functions) that do not have any unhandled effects left, can be executed, which can be statically checked at compile time~\cite{brachthauser2022effects}. When an effect operation gets called, execution jumps to the lexical closest matching handler implementation of that effect, which takes the arguments defined in the effect operation signature. Inside the implementation, the code can jump back to the original call site by calling |resume|, potentially multiple times~\cite{muhcu2025multipleresumptions}, which calls the continuation from before the effect operation was called. The |resume| call can also return a value to the original call site, as defined by the effect operation's signature. More about the Effekt language is explained in \Cref{chap:effekt}.

\section*{Overview and Contributions}

The goal of this thesis is to explore the feasibility and advantages of effect systems to model a game engine and its API. One part of this is the engine implementation itself, which requires complex control flow and internal logic. This should ideally be implemented with as little and easy to understand code as possible. The other part is the API, which should be as simple, straightforward and ergonomic as possible. Both of these implementations are explored to show the advantage effects and handlers provide for these scenarios.

The main contribution of this thesis is the implementation of a simple 2D game engine and API using the Effekt language, which can be found on GitHub\footnote{\url{https://github.com/airzocker/Effekt-Game-Engine-Thesis}}. Implementing the engine involved finding ways to use Effekt's functionality as advantages in implement a game engine based on an ECS, compared to existing approaches. As a side product, it also serves as a usability test and case study of the effekt language for a larger and more complicated project.

A simple but fully functional ECS builds the basis for all other engine components. Features of the Effekt language are used to make compact code with comprehensible logic, but complex control flow. This leads to an implementation of the ECS in approximately 800 lines of code. A html5 \textsf{canvas} 2D renderer and input system are built on top of the ECS, while also using the `foreign function interface' (\textit{ffi}). Once the Effekt language and general ECS concepts are understood, usage of the engine is therefore straightforward and based only on a few interfaces.

To avoid implementing low-level window creation, graphics and input, the code is currently compiled to the \textsf{js-web} target. The \textit{ffi} is used to interoperate with JavaScript functions from Effekt code. On the web target, the browser allows us to use the JavaScript event loop for input events and the html5 \textsf{canvas} API for simple graphics using the \textit{ffi}.

\section*{Structure of the Thesis}

In this thesis we discuss some existing small or research-focused game engines and compare their working principles in \Cref{chap:existing}, introducing the Entity Component System architecture as well. In \Cref{chap:effekt} we go over the Effekt language and some of its most important features for this thesis. Then we describe the implementation of our game engine and its core differences to other game engines and ECSs in \Cref{chap:engine}. In \Cref{chap:details} we go over details of the game engine and how Effekt was used to make it easy to use. Then we present a case study of a `Snake' game implementation in \Cref{chap:casestudy}. Afterward, we discuss some improvements, limitations and possible future work in \Cref{chap:discussion}. At last, we present the Conclusion of this thesis.
