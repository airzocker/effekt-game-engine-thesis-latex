\chapwithtoc{Introduction}\label{chap:introduction}

\section{Game engines}

Game engines are used to create video games, which makes it part of a very big industry. Video games need to do massive realtime calculations on consumer hardware, which makes game engines often show some of the most impressive algorithms and techniques, mainly related to computer graphics. Game engines exist in various types and flavours, like smaller ones that are made for academic research or to make lightweight games as simple and straight-forward as possible to implement. Other game engines are backed by big companies and are feature rich, tailored towards performant implementation of big and graphically advanced games.

Game engines range from simple libraries that introduce often used functions for rendering, animation, sound and more to whole frameworks that manage the complete execution flow of the game. There are even big editor programs that build together a game from all the configuration made in a graphical user interface, which often include graphical editors for scene layout, animations, shaders, asset file management and more.

\section{Entity Component System}

The Entity Component System is not \textit{a} system, but an architecture/pattern that is often used in game engines. It is based on the principal `composition over inheritance' and therefore uses a data-oriented design instead of an object oriented design. It models the \textit{world} in terms of components, entities and systems.

\textit{Components} are a single piece of data, like a simple struct, for example a player/characters `Health' (Integer) or `Velocity' (2D/3D Vector). \textit{Entities} are usually just an identifier or index, that identifies a single collection of these (different) components that work together to create that entity implicitly. \textit{Systems} are functions that actually transform the components from one state to the following one, acting on a `Query' of components, independent of the purpose of the corresponding entities. These systems should not hold any data themselves, as they are only meant to define the code that transforms a set of components.

For single instance data, like `Time' or `Assets', some ECSs introduce \textit{Resources} that can be used inside a system besides component queries to hold a single value that does not belong to any entity. Other ECSs use a `Singleton' entity concept for that, which ensures that such a global resource is added to one entity only. These systems can then be run by the engine in their order every frame for single threaded applications. For efficient multithreading, the systems can be scheduled in parallel while avoiding any race conditions or modification during iteration. This can be done by making sure only one system has write acess to a specific component type at the same time.

\section{Effekt language}

Effekt is a research programming language developed by the Software Engineering chair at the Universität Tübingen. It has an effect system and features concepts like effects, effect handlers, bidirectional effects, compile-time polymorphism, existential types and complex control flow concepts using continuations and a `program stack'. The language has so far been used mostly for smaller algorithms and systems that use the features of the language to implement them much simpler than in other languages or to showcase its features.

\textit{Effects} are like generalized exceptions. An effect can be defined by a single function or an `interface' defines multiple functions that need to be implemented to handle the effect. These functions can then be called anywhere in the program, which makes the used effect get statically added as part of the type of the surrounding function. This effect then needs to be handled by an \textit{effect handler} in the surrounding code, similar to an exception handler. Only programs (`main' functions) that do not have any unhandled effects left can be executed, which can be statically checked at compile time. When an effect function gets called, the execution jumps to the corresponding implementation of the closest handler of that effect, which can take any types as arguments defined in the effect function signature. Inside the implementation, the code can jump back to the original callsite by calling `resume', which calls the continuation from before the effect function was called. The `resume' call can also give an argument back to the original callsite, which is also defined by the effect function signature.

\section{Effekt game engine}

The main contribution of this thesis is my implementation of a simple 2D game engine using Effekt as the language. This should mainly serve as a usability test and case study of the effekt language for a larger and more complicated project. The code is compiled to the `js-web' target in this case, as that is the easiest way to avoid programming the low-level implementation of window creation, graphics and input. Using the `foreign function interface' (\textit{ffi}) with javascript in the browser allows me to use the javascript event loop for input events and the html5 `canvas' API for simple graphics.

I implemented an ECS as the basis for everything else and built a html5 `canvas' 2D renderer and input system on top of that, using the ffi. Usage of the engine is therefore straightforward and relatively simple, after knowing the Effekt language and general ECS concepts. The features of the Effekt language are used to make very compact code with easily comprehensible logic, but very complex control flow. This, for example, leads to an implementation of the ECS in only about 800 lines of code, which is very short for its rich feature set.

\section{Structure of the Thesis}

In this thesis I will go over some of the existing smaller or research focused game engines and compare their working principles in chapter 1, introducing the Entity Component System architecture/pattern as well. In chapter 2 I will go over the Effekt language and some of its most important features for my thesis. Then I will get into the implementation of my game engine and its core differences to other game engines and ECSs in chapter 3. In chapter 4 I will go over details of my game engine and how I used Effekt to make it easy to use. Then I will present a case study of my `Snake' implementation in chapter 5. After that I will discuss some improvements, limitations and possible future work in chapter 6. In the final chapter 7, I will present my conclusion of the thesis.
