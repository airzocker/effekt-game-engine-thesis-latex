\chapwithtoc{Introduction}\label{chap:introduction}

\section{Game engines}

Game engines are used to create video games, which makes it part of a very big industry. Video games need to do massive realtime calculations on consumer hardware, which often makes game engines showcase some of the most impressive algorithms and techniques, mainly related to computer graphics. Game engines exist in various types and flavours, like smaller ones that are made for academic research or to make lightweight games as simple and straight-forward as possible to implement. Other game engines are backed by big companies and are feature-rich, tailored towards performant implementation of big and graphically advanced games.

Game engines range from simple libraries that introduce often used functions for rendering, animation, sound and more to whole frameworks that manage the complete execution flow of the game. There are even big editor programs that build a game from scripts and configuration made in a graphical user interface, which often include graphical editors for scene layout, animations, shaders, asset file management and more.

\section{Entity Component System}

The Entity Component System is not a single system, but rather an architectural pattern that is often used in game engines. It is based on the principle `composition over inheritance' and therefore uses a data-oriented design instead of an object oriented design. It models the \textit{world} in terms of components, entities and systems.

\textit{Components} are a single piece of data, like a simple struct, for example a player`s/NPC character`s `Health' (Integer) or `Velocity' (2D or 3D Vector). \textit{Entities} are usually just an identifier or index, that identifies a single collection of these (different) components that work together to create that entity implicitly. \textit{Systems} are functions that actually transform components from one state to the next, acting on a `Query' of components, independent of the purpose of the corresponding entities. These systems should not hold any data themselves, as they are only meant to define the code that transforms a set of components.

For single instance data, like `Time' or `Assets', some ECSs introduce \textit{Resources} that can be used inside a system besides component queries to hold a single value that does not belong to any entity. Other ECSs use a `Singleton' entity concept for that, which ensures that such a global resource is added to one entity only. These systems can then be run by the engine in their order every frame for single threaded applications. For efficient multithreading, the systems can be scheduled in parallel while avoiding any race conditions or modification during iteration. This can be done by making sure only one system has write access to a specific component type at the same time.

\section{Effekt language}

Effekt is a research programming language developed by the Software Engineering chair at the Universität Tübingen. It has an effect system and features concepts like effects, effect handlers, bidirectional effects, compile-time polymorphism, existential types and complex control flow concepts using continuations and a `program stack'. The language has so far been used mostly for smaller algorithms and systems that use the features of the language to implement them much simpler than in other languages or to showcase its features.

\textit{Effects} are like generalized exceptions. An effect can be defined by a single function or an `interface' that defines multiple functions which need to be implemented to handle the effect. These functions can then be called anywhere in the program, which makes the used effect get statically added as part of the type of the surrounding function. This effect then needs to be handled by an \textit{effect handler} in the surrounding code, similar to an exception handler. Only programs (`main' functions) that do not have any unhandled effects left can be executed, which can be statically checked at compile time. When an effect function gets called, execution jumps to the closest matching handler implementation of that effect, which takes the arguments defined in the effect function signature. Inside the implementation, the code can jump back to the original callsite by calling `resume', which calls the continuation from before the effect function was called. The `resume' call can also return a value to the original call site, as defined by the effect function`s signature.

\section{Effekt game engine}

The main contribution of this thesis is my implementation of a simple 2D game engine using Effekt as the language. This should mainly serve as a usability test and case study of the effekt language for a larger and more complicated project. The code is compiled to the `js-web' target in this case, as that is the easiest way to avoid implementing low-level window creation, graphics and input. Using the `foreign function interface' (\textit{ffi}) with javascript in the browser allows me to use the javascript event loop for input events and the html5 `canvas' API for simple graphics.

I implemented an ECS as the basis for everything else and built a html5 `canvas' 2D renderer and input system on top of that, using the ffi. Usage of the engine is therefore straightforward and relatively simple, once the Effekt language and general ECS concepts are understood. The features of the Effekt language are used to make very compact code with easily comprehensible logic, but very complex control flow. This, for example, leads to an implementation of the ECS in approximately 800 lines of code, which is very short for its rich feature set.

\section{Structure of the Thesis}

In this thesis I discuss some existing small or research-focused game engines and compare their working principles in chapter 1, introducing the Entity Component System architecture/pattern as well. In chapter 2 I go over the Effekt language and some of its most important features for my thesis. Then I describe the implementation of my game engine and its core differences to other game engines and ECSs in chapter 3. In chapter 4 I go over details of my game engine and how I used Effekt to make it easy to use. Then I present a case study of my `Snake' implementation in chapter 5. Afterward, I discuss some improvements, limitations and possible future work in chapter 6. In the final chapter 7, I present my conclusion of the thesis.
