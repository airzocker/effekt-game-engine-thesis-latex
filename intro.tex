\chapwithtoc{Introduction}\label{chap:introduction}

\section{Game engines}

Game engines are used to create video games, which makes it part of a very big industry. Video games need to do massive realtime calculations on consumer hardware, which often makes game engines showcase some of the most impressive algorithms and techniques, mainly related to computer graphics. Game engines exist in various types and flavours, like smaller ones that are made for academic research or to make lightweight games as simple and straight-forward as possible to implement. Other game engines are backed by big companies and are feature-rich, tailored towards performant implementation of big and graphically advanced games.

Game engines range from simple libraries that introduce often used functions for rendering, animation, sound and more to whole frameworks that manage the complete execution flow of the game. There are even big editor programs that build a game from scripts and configuration made in a graphical user interface, which often include graphical editors for scene layout, animations, shaders, asset file management and more.

\section{Entity Component System}

The Entity Component System concept is not a single system, but rather an architectural pattern that is often used in game engines. It is based on the principle `composition over inheritance' and therefore uses a data-oriented design instead of an object oriented design. It models a \textit{world} in terms of components, entities and systems.

\textit{Components} are a single piece of data, like a simple struct, for example a player`s/NPC character`s \textit{Health} (Integer) or \textit{Velocity} (2D or 3D Vector). \textit{Entities} are usually just an identifier or index, that identifies a single collection of these (different) components that work together to create that entity implicitly. For single instance data, like \textit{Time} or \textit{Assets}, some ECSs introduce \textit{Resources} that can be used inside a system besides component queries to hold a single value that does not belong to any entity. Other ECSs use a \textit{Singleton entity} concept for that, which ensures that such a global resource is added to one entity only.

\textit{Systems} are functions that actually transform components from one state to the next, acting on a \textit{Query} of components, independent of the purpose of the corresponding entities. These systems should not hold any data themselves, as they are only meant to define the code that transforms a set of components. These systems can then be run by the engine in their order every frame for single threaded applications. For efficient multithreading, the systems can be scheduled in parallel while avoiding any race conditions or modification during iteration. This can be done by making sure only one system has write access to a specific component type at the same time.

\section{Effekt language}

Effekt is a research programming language developed by the Software Engineering group at the Universität Tübingen. It has an effect system and features concepts like effects, effect handlers, bidirectional effects, compile-time polymorphism, existential types and complex control flow concepts using continuations and a `program stack'. The language has so far been used mostly for smaller algorithms and systems that use the features of the language to implement them much simpler than in other languages or to showcase its features.

\textit{Effects} are like generalized exceptions. An |effect| can be defined by a single operation (function) or an |interface| that defines multiple operations which need to be implemented to handle the effect. These operations can then be called anywhere in the program, which makes the used effect get statically added as part of the type of the surrounding function. This effect then needs to be handled by an \textit{effect handler} in the surrounding code, similar to an exception handler. Only programs (`main' functions) that do not have any unhandled effects left can be executed, which can be statically checked at compile time. When an effect operation gets called, execution jumps to the closest matching handler implementation of that effect, which takes the arguments defined in the effect operation signature. Inside the implementation, the code can jump back to the original callsite by calling `resume', which calls the continuation from before the effect operation was called. The `resume' call can also return a value to the original call site, as defined by the effect operation`s signature.

\section{Effekt game engine}

The main contribution of this thesis is the implementation of a simple 2D game engine using the Effekt language. That involved finding ways to use Effekt`s functionality as advantages in implement a game engine based on an ECS compared to existing approaches. As a side product, it also serves as a usability test and case study of the effekt language for a larger and more complicated project. To avoid implementing low-level window creation, graphics and input, the code is compiled to the \textsf{js-web} target for now. The `foreign function interface' (\textit{ffi}) is used to interoperate with javascript functions from Effekt code. On the web target, the browser allows us to use the javascript event loop for input events and the html5 \textsf{canvas} API for simple graphics using the \textit{ffi}.

A simple but fully functional ECS builds the basis for all other engine components. Features of the Effekt language are used to make very compact code with easily comprehensible logic, but very complex control flow. This leads to an implementation of the ECS in approximately 800 lines of code, which is quite short for its rich feature set. A html5 \textsf{canvas} 2D renderer and input system are built on top of the ECS, while also using the \textit{ffi}. Once the Effekt language and general ECS concepts are understood, usage of the engine is therefore straightforward.

\section{Structure of the Thesis}

In this thesis we discuss some existing small or research-focused game engines and compare their working principles in chapter 1, introducing the Entity Component System architecture/pattern as well. In chapter 2 we go over the Effekt language and some of its most important features for this thesis. Then we describe the implementation of our game engine and its core differences to other game engines and ECSs in chapter 3. In chapter 4 we go over details of our game engine and how I used Effekt to make it easy to use. Then we present a case study of a `Snake' game implementation in chapter 5. Afterward, we discuss some improvements, limitations and possible future work in chapter 6. In the final chapter 7, we present our conclusion of the thesis.
