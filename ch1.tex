\chapter{Existing ECS and Game Engines}\label{chap:engines}

\section{ECS concept}

A data-driven entity-based architecture with component databases for games was first implemented by the game \textsf{Thief: The Dark Project} (Looking Glass Studios, 1998). They had many financial problems during their development which shifted the focus of the game, but managed to release it working well. This was in part to their \textsf{Dark Object System}, which was the foundation for their \textsf{Dark Engine}. The system is an ECS-like database for managing all of the objects and assets in the world. It allowed game designers to modify and add/remove objects without changing code. This system worked so well, that they used it in their later game \textsf{System Shock 2} (1999), which for the most part even used the same executable of the engine.

After that, Scott Bilas from \textsf{Gas Powered Games} presented the approach they used for their \textsf{Dungueon Siege} game, with the title \textsf{A Data-Driven Game Object System} in 2002 \footnote{\url{https://www.gamedevs.org/uploads/data-driven-game-object-system.pdf}}. They needed a flexible system to manage over 7300 unique objects and over 100000 total objects in continuous, dynamically loaded maps. This should also work without engineers needing to modify and potentially hack/work around code, with the goal to empower designers to directly add objects and functionality to the world. For this problem, they also invented an object system, although it was quite different from modern ECS implementations. This presentation started to increase the attention around the ECS/data-driven architecture for games.

In 2007 Mick West from Neversoft also talked about their ECS in the article \textsf{Evolve Your Hierarchy} \footnote{\url{https://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/}}. It was further popularized by Adam Martin in his extensive blogposts starting in 2007, with the title \textsf{Entity Systems are the future of MMOG development} \footnote{\url{https://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/}}. He also established most of the modern terminoligy and concepts, like systems being first-class elements that actually hold (just) their code, components holding raw data and entities being just identifiers.

The main principle of ECS is composition over inheritance, which has many advantages not only related to performance but flexibility, making large projects easier to expand, debug and faster to change. Performance, if optimized right, can also be much higher for large/complex scenes, as systems iterate sequentially over the required components of relevant entities. As they are mostly saved close to another, iteration is also very cache-friendly. Additionally, ECS architectures can be parallelized very easily across multiple threads, by analyzing dependencies of systems and scheduling them to avoid multiple mutable access to the same components.

\section{Existing ECS libraries}

The ECS architecture has been used in a wide range of applications, but mainly in the fields of games, simulations and other graphical/interactable media. One example is `Vico: An entity-component-system based co-simulation framework'~\cite{hatledal2021vico}. Others have improved parts of the concept, such as implementing wait-free hash maps for component access~\cite{lange2016wait}. Many more ECS libraries have been devoloped without written papers about them. Most of them are standalone for general purpose, but still intended for games and similar applications. There are so many ECS libraries in fact, that we cannot go into details comparing or grouping them, as that would be too much for the scope of this thesis. We will however go over some of the differences and data structures they use.

The first and one of the most important concepts is the memory layout of stored components. One approach is the \textit{archetype} concept, which my ECS uses as well. This means that any specific set of components an entity has at one time is called its archetype, which usually is dynamic. For dynamic approaches, any component can be added or removed from an entity at runtime, which makes it change archetypes dynamically. Examples of ECS libraries with archetypes include \textsf{flecs}\footnote{\url{https://github.com/SanderMertens/flecs}}, \textsf{decs}\footnote{\url{https://github.com/vblanco20-1/decs}}, \textsf{apecs} (by schell)\footnote{\url{https://github.com/schell/apecs}}, \textsf{hecs}\footnote{\url{https://github.com/Ralith/hecs}}, \textsf{legion}\footnote{\url{https://github.com/amethyst/legion}} and the Unity DOTS ecs package\footnote{\url{https://unity.com/ecs}}. Some of these ECS libraries combine that with a chunked approach, which splits the components of every archetype over multiple chunks, usually around 16 kB in size and memory alignment. This optimizes cache efficiency while not having to reallocate the whole array/vector when its current size limit is reached.

Another commonly used memory layout are \textit{sparse sets}, which in its core use two arrays/vectors; One is sparse and stores an index based on an item`s directly, which then points to an index in the dense array/vector where the actual data is. This dense data array/vector has no empty indices and is therefore ideal for iteration, while the sparse one is used to locate or add/remove single components. This concept is used, for example, in the ECS libraries \textsf{shipyard}\footnote{\url{https://github.com/leudz/shipyard}} and the well-known \textsf{EnTT}\footnote{\url{https://github.com/skypjack/entt}}, which is used in the game \textsf{Minecraft} (by Mojang)\footnote{\url{https://www.minecraft.net}} among others. Other ECS libraries like \textsf{bevy\textunderscore ecs}\footnote{\url{https://github.com/bevyengine/bevy/tree/main/crates/bevy_ecs}} from the \textsf{Bevy}\footnote{\url{https://bevyengine.org/}} game engine use a hybrid approach, where in this case either a simple table layout can be used for fast iteration where all components of a type are stored in a single column, or a sparse set.

Other differences between the existing ECS libraries are mostly their API with the amount of boilerplate code needed and their additional features, that go beyond the very basic and essential core of an ECS. Some require more boilerplate code to use, but can be more idiomatic for the language and potentially easier to understand and work with in large projects. Others are based on the principle to make it as easy and simple to use with the least code possible. Additional features many of the existing libraries provide include systems instead of using queries explicitly and (multithreaded) scheduling for systems. Some also have change detection to filter components that might need to be processed again, as well as relations/relationships that can build the basis for parent/child hierarchies and other relations. A few libraries also include events and triggers/observers to avoid iterating many entities when only sometimes a single event is fired that needs the entities to be processed again.

\section{ECS in existing game engines}



\section{Categorizing existing game engines}


