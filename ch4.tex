\chapter{Engine implementation details and problems}\label{chap:details}

\section{Component implementation}

A \textit{Component} handler creates a dynamic (resizable) array, containing all the values of that component without any empty indices. To access a component value (get or set), a component index is used. When a new component is added, it is pushed at the end of the array. Removing an index works by swapping that value with the last one and popping that last index from the array. This returns the index that was at the end before, so the surrounding/calling code can update the component index of that entity to point to the newly swapped index.

The engine internals use the component stores of each component type to store all of those values, without separating them by archetype. This way, iteration is usually not in order, but it reduces complexity and indirection. Any component value can be easily accessed by using the specific \textit{Component} effect and a component index.

When trying to destroy an entity with multiple components, a major issue occurs. Using the previously mentioned way to remove a component by using the index requires the \textit{Component} effect to be handled, which would need to be done for any component the entity currently has. As I strongly wanted dynamic entities, meaning any (single) component can be added or removed from an entity, the components cannot be stored as part of its static generic type. This means, the destroy entity function cannot work by using the \textit{Component} effects of all components the entity has, as that changes dynamically at runtime.

The solution for this component removal problem is using existential types and a \textit{ComponentManager}. On every component "register" using the `component' function, the \textit{ComponentManager} needs to be handled, which automatically happens when using the `world' or `engineWorld' setup functions. When a component then creates its component storage variable, it also registers it with the \textit{ComponentManager}, which gives every component type a unique index. It also stores that component storage in an array itself, wrapped in an existential type, making the type signature independed of the actual component type. When later needing to remove a component, the \textit{ComponentManager} can then be used, together with a component id and index. Inside of that remove function, the correct component storage is retrieved from an array using the id and matched on. Inside the match, that index can be removed and swapped with the last one by using the power of existential types, knowing the type of its component storage inside the removal block, without showing it in its type signature. This way, entities can be destroyed without needing to have any \textit{Component} effect handled.
