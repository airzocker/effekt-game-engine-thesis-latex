\chapter{Engine implementation details and problems}\label{chap:details}

All effect functions that are not supposed to be called by the game developer but are available, as the effect needs to be handled on the game developer side, have names prefixed with `internal...'. This is left out in the function names of the following implementation details when they are not contained in full code snippets, as it is irrelevant for the understanding and just a product of the Effekt language not having visibility modifiers (yet).

\section{Component implementation and existentials}

A \textit{Component} handler creates a dynamic (resizable) array, containing all the values of that component without any empty indices. To access a component value (get or set), a component index is used. When a new component is added, it is pushed at the end of the array. Removing an index works by swapping that value with the last one and popping that last index from the array. This returns the index that was at the end before, so the surrounding/calling code can update the component index of that entity to point to the newly swapped index.

The engine internals use the component stores of each component type to store all of those values, without separating them by archetype. This way, iteration is usually not in order, but it reduces complexity and indirection. Any component value can be easily accessed by using the specific \textit{Component} effect and a component index.

When trying to destroy an entity with multiple components, a major issue occurs. Using the previously mentioned way to remove a component by using the index requires the \textit{Component} effect to be handled, which would need to be done for any component the entity currently has. As I strongly wanted dynamic entities, meaning any (single) component can be added or removed from an entity dynamically, the component types cannot be stored as part of the type of a component group. This means, the destroy entity function cannot work by using the \textit{Component} effects of all components the entity has, since that set changes dynamically at runtime.

The solution for this component removal problem is using existential types and a \textit{ComponentManager}. On every component "register" using the `component' function, the \textit{ComponentManager} needs to be handled, which automatically happens when using the `world' or `engineWorld' setup functions. When a component then creates its component storage variable, it also registers it with the \textit{ComponentManager}, assigning every component type a unique index. It also stores that component storage in an array itself, wrapped in an existential type, making its signature independent of the actual component type. When later needing to remove a component, the \textit{ComponentManager} can then be used, together with a component id and index. Inside of that remove function, the correct component storage is retrieved from an array using the id and matched on. Inside the match, that index can be removed and swapped with the last one by using the power of existential types, knowing the type of its component storage inside the removal block, without showing it in its type signature. This way, entities can be destroyed without needing to have any \textit{Component} effect handled.

\section{Archetypes and the ArchManager implementation}

The ECS needs to manage what entities have what components. As my ECS is archetype based, my \textit{ArchManager} effect takes that role. Archetypes define a specific set of component types, so every entity belongs to an archetype and ideally many entities belong to the same archetype. When a component is added or removed from an entity, its archetype changes. The \textit{ArchManager} manages these and stores which entity belongs to which archetype. It creates an archetype whenever an entity gets a component removed or added while its new archetype is not yet present and removes archetypes that no entity belongs to anymore.

My \textit{ArchManager} effect acts as the bridge between the \textit{EntityManager} and the actual component values. It has functions to check if a component type is present on a specific entity, create and destroy entities, as well as remove a component from an entity and add/set or get the value of a component. In its handler, a resizable array is created to hold all \textit{Arch} values, each representing one archetype. Each of those has a map from a component id to a resizable array, which contain all the component indices for the specific component type. Each of these is for one of the entities belonging to this archetype, aligned with a parallel resizable array in the \textit{Arch} containing the actual \textit{Entity} values for iteration.

\section{EntityManager implementation and its API}

`Structural changes' is a term often used in ECSs to define changes that do more to the world than modify component values. They include entity creation/destruction, adding not yet present components or removing components. To summarize: `structural changes' are modifications to the world, that may lead to queries needing to recalculate their matches.

Most of the API (interaction from the game developer side) to structurally modify entities and components in the world is through the \textit{EntityManager} effect. It has functions to check if an entity exists or if it has a specific component type. It can also create and destroy entities, remove components and add/set or get component values.

The \textit{EntityManager} effect has a second handler implementation that is active inside of system bodies. They handle deferred modification, so that there is no structural modification of the queried component/entity arrays that get iterated over during modification. It forwards calls that can be executed directly to the surrounding normal \textit{EntityManager} while queuing commands that should be executed after the system, like creating entities and adding to or removing components from them. Newly created entities get reserved without yet being created, so a valid (after the system body) \textit{Entity} value can be returned which can then be used to add components to the new entity.

\section{System implementation}

A \textit{System} represents a single function or code block that gets executed once every frame of the game. When using the `system' function to add a system to the world, it wraps the current \textit{System} effect handler with a new one, which first calls the body of the existing system and then its own body. This way, nested \textit{System} handlers can be used to create a sequential chain of systems that get called in order or definition from the single step function the effect defines.

\section{Query implementation}

A \textit{Query} effect handler in conjunction with \textit{CompIter} effect handlers can be used to iterate over specific sets of components and their respective \textit{Entity}. This works everywhere the \textit{World} and its requirements are handled, but is mostly used inside systems. Iterating optional components and adding additional filters to require or exclude entities with specific components are also possible with my \textit{Query} implementation.

To create a \textit{Query}, the `query' function can be used to define a named handler for the \textit{Query} effect. By calling `withC' or `withoutC' effect functions on the named handler, additional filters can be added that do not get iterated themselves. Using the `addC' or `addOptC' effect functions, named handlers of the \textit{CompIter} effect for the respective component can be defined. These can then be used during iteration to get and set the specific component value of that type of the current entity by calling the `get' or `set' effect functions. The \textit{Query} itself can be iterated by using the `foreach' function, which iterates over the current \textit{Entity} value.

\section{World implementation and frame execution schedule}

The \textit{World} effect represents the ECS world, but it does very little on its own, as most aspects making up a world are handled by their own effects. The `world' or `engineWorld' functions are mostly there to create all the needed effect handlers.

Besides creating all the needed effect handlers in the `world' handler, it is responsible for stepping the world a single time with the `stepWorld' effect function or run it endlessly in a loop with the `runWorld' function. They both call the current \textit{System} handlers `step' effect function and in the `runWorld' case then `wait' for the next frame and give control flow back to the javascript event loop. It also registers the \textit{RunWorld} resource, which is used to exit the endless loop by checking its boolean value every frame.
